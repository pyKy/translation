.. 翻訳者: Jun Okazaki

------------------
構造的概要
------------------

このドキュメンテーションはKivyのProgramming Guide » Architectural Overviewを日本語訳したものです。
https://kivy.org/docs/guide/architecture.html

ソフトウェアエンジニアリングの始点からKivyの設計方法を説明するための時間を取りしたいと思います。
これは全体がどのように機能するかを一緒に理解する鍵です。
コードを見れば、大体のアイデアを取得できますが、そのアプローチではほとんどのユーザーが気力をくじかされるので、
このセクションでは、より詳細に実行する基本的な考え方を説明しています。
このセクションをスキップし、後に参照してもよいですが、大まかなまかな概要の理解のために
流し読みを提案します。

Kivyは、後で説明しますいくつかのビルディングブロックで構成されています。
アーキテクチャのグラフィカルな概要は次のとおりです。


.. image:: https://kivy.org/docs/_images/architecture.png


Core Providers と Input Providers
---------------------------------
Kivyの内部を理解する鍵であるひとつのアイデアは、モジュール性と抽象化です。
私たちは、ウィンドウを開き、画像やテキストを表示するやカメラから画像を取得するやスペル修正や再生などの抽象的で基本的なタスクを試みてください。
これらの機能はコアタスクを呼び出します。APIは使用しやすく、拡張が簡単という両方を兼ね備えています。
コールするもの - -最も重要なことは、アプリの実行中で、それぞれのシナリオのおかげで特定のプロバイダで使用できるようになります。
例えば、OSX、Linux、Windows上で、異なるコアタスクのための複数のネイティブAPIがあります。
Kivyの側（中間通信層として機能する）にオペレーティングシステム側と通信するために特定のAPIのいずれかを使用するコードの一部をコア・プロバイ呼んでます。
各プラットフォームに特化したコア・プロバイダを使用することの利点は完全にＯＳによって公開される機能を活用してできる限り効率的に動かせる点です。
またユーザーに選択するチャンスを与えます。
さらに、いずれかのプラットフォームに入っているライブラリを使用して、Kivyディストリビューションのサイズを効果的に小さくしてパッケージ化を簡単にします。
これはまた、Kivyの他のプラットフォームへの移植が簡単にします。
Androidのポートは、ここから大幅に恩恵を受けました。
入力処理と同じコンセプトに従ってください。
入力プロバイダは、アップルのトラックパッド、TUIOまたはマウスエミュレータとして、特定の入力デバイスのサポートが追加されたコードの一部です。
新しい入力デバイスのサポートを追加する必要がある場合は、デバイスからの入力データを読み込んでKivyの基本的なイベントに変換しした新しいクラスを提供できます。


Graphics
-----------------------
KivyGraphicsAPIは、OpenGLの私達の抽象化したものです。
最下層レベルでは、Kivyのハードウェアアクセラレータの描画コマンドissueは、OpenGLを使用しました。
しかし、OpenGLコードを書くのは初心者は特に少し混乱するかもしれません。
グラフィックスAPIを提供する理由は、OpenGL（例：Canvas, Rectangle,など）では存在しない単純なメタファーを使って描画できるようにするためです。

すべてのwidgetはパフォーマンスの理由から、Cレベルで実装されるgraphics APIを使用します。

graphicsAPIの別の利点は、問題あるコードを描画コマンドで自動的最適化する機能があります。
OpenGLのチューニングの専門家でないのならば特に便利です。これは、多くの場合、描画コードをより効率的にします。

もちろん希望する場合は、生のOpenGLのコマンドを使用できます。
私たちのターゲットバージョンは、すべてのデバイス上でOpenGL2.0 ES（GLES2）なので、クロスプラットフォームの互換性を保ちたいのならばGLES2機能を使用することをお勧めします。


Core
-----------------------

Coreパッケージ内のコードは、次のような一般的に使用される機能を提供します：

Clock
 タイマーイベントをスケジュールするためにClocを使用できます。ワンショットタイマーと周期タイマーの両方がサポートされています。
 
Cache
 頻繁に使用するものをキャッシュする必要がある場合はキャッシュは、自分で書くかわりに、クラスを使用できます。
 
Gesture Detection
 円や四角形などのストロークの様々な種類を検出するために使用できる簡単なジェスチャー認識を出力します。
 自身のストロークを検出することをトレーニングできます。 
 
Kivy Language
 Kivy Languageは容易で効率的にユーザ・インターフェースを記述するために使用されます。
 
Properties
 Pythonから知っている可能性があり、通常のプロパティではありません。
 ユーザーインターフェースの説明を使用してwidget コードをリンクする独自のpropertyクラスです。


UIX (Widgets & Layouts)
-----------------------
UIXモジュールはユーザー・インターフェースを直ぐに作成するために再利用できる一般的に使用されるwidgetとlayoutsが含まれています。

Widgets
 ｗidgetsはいくつかの種類の機能を提供するためにプログログラムに追加するユーザーインターフェイス要素です。

Layouts
 ｗidgetsを配置するLayoutsを使用しｗidgetsを配置します。それはウィジェットの座標をもちろん自分で計算することも可能ですが、多くの場合、既製のレイアウトのいずれかを使用する方が便利です。
 例えば、 Grid Layouts や Box Layoutsです。レイアウトをネストすることもできます。


Modules
-----------------------
最新のWebブラウザを使用し、いくつかのアドオンでカスタマイズしたことがある場合は、モジュールクラスの背後にある基本的な考え方を知っています。
moduleは、オリジナルの作者がmoduleを含まれていない場合でも、Kivyプログラムに機能を加えるのに使用できます。

例えば、いくつかのグラフのFPSを元のアププリケーションを描画する時間をFPSで表示したmoduleです。

また、独自のmoduleを作成することができます。


Input Events (Touches)
-----------------------
Kivyは、タッチ、マウス、TUIOまたは類似の異なる入力タイプとソースを抽象化します。
これらの入力タイプのすべてに共通しているのは、任意の個々の入力イベントと2D画面上の座標を関連付けることができるということです。
（例えばこのような簡単にあなたのデバイスの傾きを測定する、加速度計のような入力デバイスのインプットはこの種の入力が個別に処理されるめ2D座標を見つけることができません。
　以下では、我々は前者のタイプについて説明します。）

これらの入力タイプはすべて、Touch（）クラスのインスタンスで表現されます。
（注意：これは指のタッチだけでなく他のすべての入力タイプにも参照されます。
　簡略化のためにTouchと呼ばれます。
　ユーザーインターフェイスや画面を触れる何かを考えてください。）

Touchインスタンス、またはオブジェクトは3つの状態のいずれであってもよいです。
Touchは、状態のいずれかを入力すると、イベントが発生したことをプログラムは通知されます。
タッチできる3つの状態は次のとおりです。

Down
　Touchは、それが最初に表示される瞬間に、一度だけダウンします。
Move
　Touchは、潜在的に無限の時間のためにこの状態になることができます。タッチは、その生存期間中にこの状態にする必要はありません。 
　「Move」は、Touchの変更のたびに2次元座標を発生します。

Up
　Touchは、最高1回、または必ず上がります。実際には、誰もが永遠のために画面上で指を保持しようとしないので、ほとんどの場合、Upイベントを受け取りますが保証されません。
　ユーザーが使用する入力ソースを知っている場合、状態が入力に依存するこかどうかを知ることが出来ます。
　

Widgets と Event Dispatching
----------------------------
用語widgetは、多くの場合、ユーザが対話するプログラムの一部を記述するために、GUIプログラミングコンテキストで使用されています。 
Kivyでは、widgetは、入力イベントを受け取るのが目的です。
それは必ずしも画面上に表示表現を持っている必要はありません。
全てのwidgetはwidgetツリーに配置されています（コンピュータサイエンスの授業で知るツリーデータ構造がある）：一つのwidgetは子widgetまたはnoneのいずれかの番号を持つことができます。
正確には親widgetを持っていないツリーの最上部にあるroot widgetは、すべての他のwidgetは、直接または間接的にこのwidgetの子になりす。（rootと呼ばれる理由である）

新たな入力データが利用可能である場合、Kivyは、タッチごとに1つのイベントを送信します。
widgetツリーのroot widgetは、最初のイベントを受け取ります
on_touch_moveまたはon_touch_upイベントハンドラでon_touch_down対応するroot widgetは、touchの状態に応じて、on_touch_down、on_touch_moveまたはon_touch_upイベントで呼び出されることになるroot widgetにディスパッチ（引数としてtouch）されます。

ツリー内の各widget（ルートウィジェットが含む）は、イベントを渡すためにダイジェストまたはパスのどちらかを選択できます。

イベントハンドラがTrueを返した場合は、イベントが消費され、適切に処理されていることを意味します。
それ以上の処理は、このイベントに起こりません。
それ以外の場合は、イベントハンドラは、各イベントハンドラのスーパークラスの実装を呼び出すことによって、自身の子の上のwidgetを渡します.
基本Widgetクラスまでのすべての道に対していきます。 - そのtouchイベントハンドラに - しかし、何もその子たちにtouchを渡しません。

.. code-block:: python

	# This is analogous for move/up:
	def on_touch_down(self, touch):
	    for child in self.children[:]:
	        if child.dispatch('on_touch_down', touch):
	            return True


実際は最初に思っていたよりもはるかに簡単です。ナイスなアプリケーションを迅速に作成するために使用できる方法の例を次のセクションで説明します。

しばしば、widgetがtouchを監視する画面の領域を制限することになるでしょう。
実現するために、ウィジェットのcollide_point()メソッドを使用することができます。
単にtouchの座標を通過するとTouchのTrueが、一方「watch」またはFalseの範囲内にある場合にはTrueを返します。

デフォルトでは、画面上のwidgetの座標（X＆Y）とサイズ（幅＆高さ）によって記述されている矩形領域をチェックしていますが、独自のクラスでこのビヘイビアをオーバーライドすることができます。
